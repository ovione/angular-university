What does it mean to build an application in a reactive style ?

=================================================================================
Imperative Style
  code focuses on writing an explicit sequence of commands to describe how you want the computer to do things

  const double = (numbers: number[]) => {
    cont doubled: number[] = [];

    for(let i=0, i<numbers.length, i++) {
      doubled.push(numbers[i]*2);
    }

    return doubled;
  }

  console.log(double([1, 2, 3));
  result: [2, 4, 6]

Declarative Style
  code focuses on specifying the result of what you want.

  const double = (numbers: number[]) => numbers.map(n => n*2);

  console.log(double([1, 2, 3));
  result: [2, 4, 6]
=================================================================================

1.traditional Imperative Style
  https://callbackhell.com/
  sub1(()=> {
    if(bolean) {
        sub2(()=> {
           do something;
        })
    } else {
        sub3(()=> {
           do something;
        })
    }
  })

2.Reactive style
  Folow the design patterns and avoid CallBack hell.

  The Reactive style component does not know where the data is coming from.
  It uses a reactive service to retrieve the data.
  The data is not a mutable variable but an Observable.
  The data is pushed to the view by the Observable and is consumed by the html with the async pipe.
  If we want to modify the data we can use the multiple rxJs operators inside a pipe.
  Code is flat without deep level of nesting.

  The Imperative Style component knew from where the data was comming from via the http.
  The data was stored in a mutable variable.

html
  <div *ngFor="let data of (data$ | async)" >
  </div>

Component {
  data$: Observable<Data[]>;

  constructor(private service: Service) {}

  ngOnInt() {
    data$ = service.method()
  }
}

Service {
  constructor(private http: Http) {}

  method(): Observable<Data[]> {
    http.get<Data[]>('uri').
    pipe(
      map(this.someMappingFunc())
    );
  }

  private someMappingFunc(res): Data[] {
    return res['payload'];
  }
}

JSON returned by http:
{
  payload: [
    Data1, Data2, ... DataN
  ]
}

Design Pattern 1
------------------------------
Create a stateless service to help the component.
A Reactive Service is a service that has methods that return Observables().

Design Pattern 2
------------------------------
Components passes data to the view as Observables.
All data from the components are Observables and not mutable variables.

Design Pattern 3
------------------------------
Use the async pipe.
The async pipe will subscribe to the Observable.
When the component is destroyed the async pipe will unsubscribe the subscription to prevent memory leaks.

Design Pattern 4
------------------------------
Avoiding Angular duplicate HTTP requests with the RxJs shareReplay operator

  service.method.subscribe
  .pipe(
    map(),
    shareReplay()
  )
  .(() => {})

Design Pattern 5
------------------------------
Smart Components vs Presentational Components

Smart Components: Apply logic to prepare the data and uses the Presentational Components.
Presentational Components:  Only displays without any other logic.















































